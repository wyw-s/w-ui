(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{12:function(n,e,t){"use strict";t.r(e);var o=function(){var n=this.$createElement;this._self._c;return this._m(0)};o._withStripped=!0;var i=t(0),l=Object(i.a)({},o,[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("section",{staticClass:"content element-doc markdown-body"},[t("blockquote",[t("p",[n._v("概述：一个处理函数会在延迟n秒后触发，如果在n秒内再次触发那么回重新计时；")])]),n._v(" "),t("ol",[t("li",[t("p",[n._v("影响：")]),n._v(" "),t("pre",[t("code",{staticClass:"language-html"},[n._v("前端开发过程中的resize，scroll，mousemove，mousehover等，会被频繁地出发，不做限制的话，有可能一秒之内执行几十次，几百次，如果在这些函数内部执行了其他函数，尤其是执行了操作了DOM的函数，那不仅会造成计算机资源的浪费，还会降低程序运行速度，甚至造成浏览器卡死，崩溃。\n")])])]),n._v(" "),t("li",[t("p",[n._v("例：")]),n._v(" "),t("pre",[t("code",{staticClass:"language-javascript"},[n._v("<script>\n    var throttle = function(func, delay) {\n      // 存储定时器id;\n      var timer = null\n      return function(...args) {\n        // 判断定时器是否在执行中；\n        if (timer) {\n          // 在每次开始之前清除以前的定时器；\n          clearTimeout(timer)\n        }\n        timer = setTimeout(function() {\n          func(...args)\n        }, delay)\n      }\n    }\n    // 要进行处理的函数；\n    function handle() {\n      console.log(Math.random())\n    }\n    window.addEventListener('mousemove', throttle(handle, 1000))\n  <\/script>\n")])])])]),n._v(" "),t("blockquote",[t("p",[n._v("优点：防止用户由于过快的操作而发起的无用的请求；")]),n._v(" "),t("p",[n._v("使用场景：")]),n._v(" "),t("p",[n._v("1、淘宝的导航列表;")]),n._v(" "),t("p",[n._v("2、搜索框搜索输入。只需用户最后一次输入完成，在发送请求；")]),n._v(" "),t("p",[n._v("3、浏览器的窗口大小改变后，只需窗口调整完成后，在执行"),t("code",[n._v("resize")]),n._v("里面是代码，防止重新渲染；")])])])}],!1,null,null,null);l.options.__file="example/docs/installation.md";e.default=l.exports}}]);